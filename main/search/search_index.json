{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ProxyStore Extensions","text":"<p>Extensions for the ProxyStore package.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install proxystore-ex\n</code></pre> <p>See the Installation guide for more information about the available extra install options. For local development, see the Contributing guide.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>ProxyStore's documentation is available at docs.proxystore.dev and supplemental documentation for the extensions package is available at extensions.proxystore.dev.</p>"},{"location":"installation/","title":"Installation","text":"<p>We always recommend installing packages inside of your virtual environment of choice. E.g., <pre><code>$ python -m venv venv\n$ . venv/bin/activate\n</code></pre></p> <p>Once your virtual environment is activated, ProxyStore Extensions with <code>pip</code>.</p> <p>note::     ProxyStore Extensions will install ProxyStore as a dependency. However,     none of the extra options will be included with ProxyStore. See the     ProxyStore Installation     guide for how to install the base ProxyStore package with extra options.</p> <pre><code>$ pip install proxystore-ex\n</code></pre>"},{"location":"installation/#distributed-in-memory-connectors","title":"Distributed In-Memory Connectors","text":"<p>The <code>MargoConnector</code> and <code>UCXConnector</code> have additional manual installation steps to be completed before they can be used.</p> <ul> <li>Margo:<ul> <li>Install Mochi-Margo and the dependencies</li> <li>Install Py-Mochi-Margo</li> </ul> </li> <li>UCX:<ul> <li>Install UCX</li> <li>Install UCX-Py</li> </ul> </li> </ul>"},{"location":"known-issues/","title":"Known Issues","text":"<p>There are no known issues at this time.</p>"},{"location":"api/","title":"proxystore_ex","text":"<code>proxystore_ex/__init__.py</code> <p>ProxyStore extensions package.</p>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>proxystore_ex</li> <li>proxystore_ex.connectors<ul> <li>dim<ul> <li>exceptions</li> <li>margo</li> <li>models</li> <li>ucx</li> <li>utils</li> <li>zmq</li> </ul> </li> </ul> </li> </ul>"},{"location":"api/connectors/","title":"proxystore_ex.connectors","text":"<code>proxystore_ex/connectors/__init__.py</code> <p>Connector implementations.</p> <p>This is an extension of the <code>proxystore.connectors</code> module.</p>"},{"location":"api/connectors/dim/","title":"proxystore_ex.connectors.dim","text":"<code>proxystore_ex/connectors/dim/__init__.py</code> <p>Distributed in-memory store connectors.</p>"},{"location":"api/connectors/dim/exceptions/","title":"proxystore_ex.connectors.dim.exceptions","text":"<code>proxystore_ex/connectors/dim/exceptions.py</code> <p>Exception types.</p>"},{"location":"api/connectors/dim/exceptions/#proxystore_ex.connectors.dim.exceptions.ServerTimeoutError","title":"ServerTimeoutError","text":"<p>             Bases: <code>Exception</code></p> <p>Error indicating client timed out while trying to connect to server.</p>"},{"location":"api/connectors/dim/margo/","title":"proxystore_ex.connectors.dim.margo","text":"<code>proxystore_ex/connectors/dim/margo.py</code> <p>Margo RPC-based distributed in-memory connector implementation.</p>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.Protocol","title":"Protocol","text":"<p>             Bases: <code>Enum</code></p> <p>Available Mercury plugins and transports.</p>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.Protocol.OFI_TCP","title":"OFI_TCP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OFI_TCP = 'ofi+tcp'\n</code></pre> <p>libfabric tcp provider (TCP/IP)</p>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.Protocol.OFI_VERBS","title":"OFI_VERBS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OFI_VERBS = 'ofi+verbs'\n</code></pre> <p>libfabric Verbs provider (InfiniBand or RoCE)</p>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.Protocol.OFI_GNI","title":"OFI_GNI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OFI_GNI = 'ofi+gni'\n</code></pre> <p>libfabric GNI provider (Cray Aries)</p>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.Protocol.UCX_TCP","title":"UCX_TCP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UCX_TCP = 'ucx+tcp'\n</code></pre> <p>UCX TCP/IP</p>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.Protocol.UCX_VERBS","title":"UCX_VERBS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UCX_VERBS = 'ucx+verbs'\n</code></pre> <p>UCX Verbs</p>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.Protocol.SM_SHM","title":"SM_SHM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SM_SHM = 'sm+shm'\n</code></pre> <p>Shared memory shm</p>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.Protocol.BMI_TCP","title":"BMI_TCP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BMI_TCP = 'bmi+tcp'\n</code></pre> <p>BMI tcp module (TCP/IP)</p>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.MargoConnector","title":"MargoConnector","text":"<pre><code>MargoConnector(\n    port: int,\n    protocol: Protocol | str,\n    address: str | None = None,\n    interface: str | None = None,\n    timeout: float = 1,\n    force_spawn_server: bool = False,\n)\n</code></pre> <p>Margo RPC-based distributed in-memory connector.</p> Note <p>The first instance of this connector created on a process will spawn a <code>MargoServer</code> that will store data. Hence, this connector just acts as an interface to that server.</p> <p>Parameters:</p> <ul> <li> <code>port</code>             (<code>int</code>)         \u2013          <p>The desired port for the spawned server.</p> </li> <li> <code>protocol</code>             (<code>Protocol | str</code>)         \u2013          <p>The communication protocol to use.</p> </li> <li> <code>address</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The network IP to use for transfer. Has precedence over <code>interface</code> if both are provided.</p> </li> <li> <code>interface</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The network interface to use. <code>addr</code> has precedence over this attribute if both are provided.</p> </li> <li> <code>timeout</code>             (<code>float</code>, default:                 <code>1</code> )         \u2013          <p>Timeout in seconds to try connecting to a local server before spawning one.</p> </li> <li> <code>force_spawn_server</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Force spawn a server rather than waiting to check if one is already running.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServerTimeoutError</code>           \u2013          <p>If a local server cannot be connected to within <code>timeout</code> seconds, and a new local server does not respond within <code>timeout</code> seconds after being started.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def __init__(\n    self,\n    port: int,\n    protocol: Protocol | str,\n    address: str | None = None,\n    interface: str | None = None,\n    timeout: float = 1,\n    force_spawn_server: bool = False,\n) -&gt; None:\n    # Py-Mochi-Margo is not a required dependency and requires the user\n    # to install it themselves.\n    if pymargo_import_error is not None:  # pragma: no cover\n        raise pymargo_import_error\n\n    self._address = address\n    self._interface = interface\n    self.port = port\n    self.protocol = (\n        protocol if isinstance(protocol, str) else protocol.value\n    )\n\n    self.timeout = timeout\n    self.force_spawn_server = force_spawn_server\n\n    self.engine = Engine(\n        self.protocol,\n        mode=pymargo.client,\n        use_progress_thread=True,\n    )\n\n    if self._address is not None:\n        self.address = self._address\n    elif self._interface is not None:  # pragma: darwin no cover\n        self.address = get_ip_address(self._interface)\n    else:\n        eng_url = str(self.engine.addr())\n        self.address = eng_url.split(':')[1].split('/')[2]\n\n    self.url = f'{self.protocol}://{self.address}:{self.port}'\n\n    self._rpcs = {\n        'evict': self.engine.register('evict'),\n        'exists': self.engine.register('exists'),\n        'get': self.engine.register('get'),\n        'put': self.engine.register('put'),\n    }\n\n    server_available = False\n    if not force_spawn_server:\n        try:\n            logger.info(\n                f'Connecting to local server (address={self.url})...',\n            )\n            wait_for_server(\n                self.protocol,\n                self.address,\n                self.port,\n                self.timeout,\n            )\n            logger.info(\n                f'Connected to local server (address={self.url})',\n            )\n            server_available = True\n        except ServerTimeoutError:\n            logger.info(\n                'Failed to connect to local server '\n                f'(address={self.url}, timeout={self.timeout})',\n            )\n\n    self.server: multiprocessing.context.SpawnProcess | None\n    if not server_available or force_spawn_server:\n        self.server = spawn_server(\n            self.protocol,\n            self.address,\n            self.port,\n            spawn_timeout=self.timeout,\n        )\n        logger.info(f'Spawned local server (address={self.url})')\n    else:\n        self.server = None\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.MargoConnector.close","title":"close()","text":"<pre><code>close(kill_server: bool = True) -&gt; None\n</code></pre> <p>Close the connector.</p> <p>Parameters:</p> <ul> <li> <code>kill_server</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to kill the server process. If this instance did not spawn the local node's server process, this is a no-op.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def close(self, kill_server: bool = True) -&gt; None:\n    \"\"\"Close the connector.\n\n    Args:\n        kill_server: Whether to kill the server process. If this instance\n            did not spawn the local node's server process, this is a\n            no-op.\n    \"\"\"\n    if kill_server and self.server is not None:\n        self.engine.lookup(self.url).shutdown()\n        self.server.join()\n        logger.info(\n            'Terminated local server on connector close '\n            f'(pid={self.server.pid})',\n        )\n\n    self.engine.finalize()\n    logger.info('Closed Margo connector')\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.MargoConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the connector configuration.\n\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\n    return {\n        'address': self._address,\n        'interface': self._interface,\n        'port': self.port,\n        'protocol': self.protocol,\n        'timeout': self.timeout,\n        'force_spawn_server': self.force_spawn_server,\n    }\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.MargoConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; MargoConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>dict[str, Any]</code>)         \u2013          <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; MargoConnector:\n    \"\"\"Create a new connector instance from a configuration.\n\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\n    return cls(**config)\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.MargoConnector.evict","title":"evict()","text":"<pre><code>evict(key: DIMKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>DIMKey</code>)         \u2013          <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def evict(self, key: DIMKey) -&gt; None:\n    \"\"\"Evict the object associated with the key.\n\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\n    rpc = RPC(operation='evict', key=key)\n    self._send_rpcs([rpc])\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.MargoConnector.exists","title":"exists()","text":"<pre><code>exists(key: DIMKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>DIMKey</code>)         \u2013          <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def exists(self, key: DIMKey) -&gt; bool:\n    \"\"\"Check if an object associated with the key exists.\n\n    Args:\n        key: Key potentially associated with stored object.\n\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\n    rpc = RPC(operation='exists', key=key)\n    (response,) = self._send_rpcs([rpc])\n    assert response.exists is not None\n    return response.exists\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.MargoConnector.get","title":"get()","text":"<pre><code>get(key: DIMKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>DIMKey</code>)         \u2013          <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013          <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def get(self, key: DIMKey) -&gt; bytes | None:\n    \"\"\"Get the serialized object associated with the key.\n\n    Args:\n        key: Key associated with the object to retrieve.\n\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\n    buff = bytearray(key.size)\n    blk = self.engine.create_bulk(buff, bulk.write_only)\n\n    rpc = RPC(operation='get', key=key, data=blk)\n    (result,) = self._send_rpcs([rpc])\n\n    if result.exists:\n        return bytes(buff)\n\n    return None\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.MargoConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[DIMKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> <code>keys</code>             (<code>Sequence[DIMKey]</code>)         \u2013          <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013          <p>List with same order as <code>keys</code> with the serialized objects or             <code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def get_batch(self, keys: Sequence[DIMKey]) -&gt; list[bytes | None]:\n    \"\"\"Get a batch of serialized objects associated with the keys.\n\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n\n    Returns:\n        List with same order as `keys` with the serialized objects or \\\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\n    rpcs: list[RPC] = []\n    buffers: list[bytearray] = []\n\n    for key in keys:\n        buff = bytearray(key.size)\n        blk = self.engine.create_bulk(buff, bulk.write_only)\n\n        buffers.append(buff)\n        rpcs.append(RPC(operation='get', key=key, data=blk))\n\n    responses = self._send_rpcs(rpcs)\n    return [\n        bytes(b) if responses[i].exists else None\n        for i, b in enumerate(buffers)\n    ]\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.MargoConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; DIMKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>             (<code>bytes</code>)         \u2013          <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DIMKey</code>         \u2013          <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def put(self, obj: bytes) -&gt; DIMKey:\n    \"\"\"Put a serialized object in the store.\n\n    Args:\n        obj: Serialized object to put in the store.\n\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\n    key = DIMKey(\n        dim_type='margo',\n        obj_id=str(uuid.uuid4()),\n        size=len(obj),\n        peer_host=self.address,\n        peer_port=self.port,\n    )\n    blk = self.engine.create_bulk(obj, bulk.read_only)\n\n    rpc = RPC(operation='put', key=key, data=blk)\n    self._send_rpcs([rpc])\n    return key\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.MargoConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[DIMKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> <code>objs</code>             (<code>Sequence[bytes]</code>)         \u2013          <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DIMKey]</code>         \u2013          <p>List of keys with the same order as <code>objs</code> which can be used to             retrieve the objects.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[DIMKey]:\n    \"\"\"Put a batch of serialized objects in the store.\n\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n\n    Returns:\n        List of keys with the same order as `objs` which can be used to \\\n        retrieve the objects.\n    \"\"\"\n    keys = [\n        DIMKey(\n            dim_type='margo',\n            obj_id=str(uuid.uuid4()),\n            size=len(obj),\n            peer_host=self.address,\n            peer_port=self.port,\n        )\n        for obj in objs\n    ]\n    rpcs: list[RPC] = []\n\n    for key, obj in zip(keys, objs):\n        blk = self.engine.create_bulk(obj, bulk.read_only)\n        rpcs.append(RPC(operation='put', key=key, data=blk))\n\n    self._send_rpcs(rpcs)\n\n    return keys\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.MargoServer","title":"MargoServer","text":"<pre><code>MargoServer(engine: Engine)\n</code></pre> <p>MargoServer implementation.</p> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def __init__(self, engine: Engine) -&gt; None:\n    self.data: dict[str, bytes] = {}\n    self.engine = engine\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.MargoServer.evict","title":"evict()","text":"<pre><code>evict(\n    handle: Handle,\n    bulk_str: Bulk,\n    bulk_size: int,\n    key: DIMKey,\n) -&gt; None\n</code></pre> <p>Remove key from local dictionary.</p> <p>Parameters:</p> <ul> <li> <code>handle</code>             (<code>Handle</code>)         \u2013          <p>The client handle.</p> </li> <li> <code>bulk_str</code>             (<code>Bulk</code>)         \u2013          <p>The buffer that will store shared data.</p> </li> <li> <code>bulk_size</code>             (<code>int</code>)         \u2013          <p>The size of the data to be received.</p> </li> <li> <code>key</code>             (<code>DIMKey</code>)         \u2013          <p>The data's key.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def evict(\n    self,\n    handle: Handle,\n    bulk_str: Bulk,\n    bulk_size: int,\n    key: DIMKey,\n) -&gt; None:\n    \"\"\"Remove key from local dictionary.\n\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer that will store shared data.\n        bulk_size: The size of the data to be received.\n        key: The data's key.\n    \"\"\"\n    self.data.pop(key.obj_id, None)\n    response = RPCResponse(operation='evict', key=key)\n    handle.respond(serialize(response))\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.MargoServer.exists","title":"exists()","text":"<pre><code>exists(\n    handle: Handle,\n    bulk_str: Bulk,\n    bulk_size: int,\n    key: DIMKey,\n) -&gt; None\n</code></pre> <p>Check if key exists within local dictionary.</p> <p>Parameters:</p> <ul> <li> <code>handle</code>             (<code>Handle</code>)         \u2013          <p>The client handle.</p> </li> <li> <code>bulk_str</code>             (<code>Bulk</code>)         \u2013          <p>The buffer that will store shared data.</p> </li> <li> <code>bulk_size</code>             (<code>int</code>)         \u2013          <p>The size of the data to be received.</p> </li> <li> <code>key</code>             (<code>DIMKey</code>)         \u2013          <p>The data's key.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def exists(\n    self,\n    handle: Handle,\n    bulk_str: Bulk,\n    bulk_size: int,\n    key: DIMKey,\n) -&gt; None:\n    \"\"\"Check if key exists within local dictionary.\n\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer that will store shared data.\n        bulk_size: The size of the data to be received.\n        key: The data's key.\n    \"\"\"\n    exists = key.obj_id in self.data\n    response = RPCResponse(operation='exists', key=key, exists=exists)\n    handle.respond(serialize(response))\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.MargoServer.get","title":"get()","text":"<pre><code>get(\n    handle: Handle,\n    bulk_str: Bulk,\n    bulk_size: int,\n    key: DIMKey,\n) -&gt; None\n</code></pre> <p>Return data at a given key back to the client.</p> <p>Parameters:</p> <ul> <li> <code>handle</code>             (<code>Handle</code>)         \u2013          <p>The client handle.</p> </li> <li> <code>bulk_str</code>             (<code>Bulk</code>)         \u2013          <p>The buffer that will store shared data.</p> </li> <li> <code>bulk_size</code>             (<code>int</code>)         \u2013          <p>The size of the data to be received.</p> </li> <li> <code>key</code>             (<code>DIMKey</code>)         \u2013          <p>The data's key.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def get(\n    self,\n    handle: Handle,\n    bulk_str: Bulk,\n    bulk_size: int,\n    key: DIMKey,\n) -&gt; None:\n    \"\"\"Return data at a given key back to the client.\n\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer that will store shared data.\n        bulk_size: The size of the data to be received.\n        key: The data's key.\n    \"\"\"\n    local_array = self.data.get(key.obj_id, None)\n    if local_array is not None:\n        local_bulk = self.engine.create_bulk(local_array, bulk.read_only)\n        self.engine.transfer(\n            bulk.push,\n            handle.get_addr(),\n            bulk_str,\n            0,\n            local_bulk,\n            0,\n            bulk_size,\n        )\n        response = RPCResponse(operation='get', key=key, exists=True)\n    else:\n        response = RPCResponse(operation='get', key=key, exists=False)\n    handle.respond(serialize(response))\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.MargoServer.put","title":"put()","text":"<pre><code>put(\n    handle: Handle,\n    bulk_str: Bulk,\n    bulk_size: int,\n    key: DIMKey,\n) -&gt; None\n</code></pre> <p>Obtain data from the client and store it in local dictionary.</p> <p>Parameters:</p> <ul> <li> <code>handle</code>             (<code>Handle</code>)         \u2013          <p>The client handle.</p> </li> <li> <code>bulk_str</code>             (<code>Bulk</code>)         \u2013          <p>The buffer containing the data to be shared.</p> </li> <li> <code>bulk_size</code>             (<code>int</code>)         \u2013          <p>The size of the data being transferred.</p> </li> <li> <code>key</code>             (<code>DIMKey</code>)         \u2013          <p>The data key.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def put(\n    self,\n    handle: Handle,\n    bulk_str: Bulk,\n    bulk_size: int,\n    key: DIMKey,\n) -&gt; None:\n    \"\"\"Obtain data from the client and store it in local dictionary.\n\n    Args:\n        handle: The client handle.\n        bulk_str: The buffer containing the data to be shared.\n        bulk_size: The size of the data being transferred.\n        key: The data key.\n    \"\"\"\n    local_buffer = bytearray(bulk_size)\n    local_bulk = self.engine.create_bulk(local_buffer, bulk.write_only)\n    self.engine.transfer(\n        bulk.pull,\n        handle.get_addr(),\n        bulk_str,\n        0,\n        local_bulk,\n        0,\n        bulk_size,\n    )\n    self.data[key.obj_id] = local_buffer\n\n    response = RPCResponse(operation='put', key=key)\n    handle.respond(serialize(response))\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.start_server","title":"start_server()","text":"<pre><code>start_server(url: str) -&gt; None\n</code></pre> <p>Start and wait on a Margo server.</p> <p>Parameters:</p> <ul> <li> <code>url</code>             (<code>str</code>)         \u2013          <p>URL of the engine that will be started. Should take the form <code>{protocol}://{host}:{port}</code>.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def start_server(url: str) -&gt; None:\n    \"\"\"Start and wait on a Margo server.\n\n    Args:\n        url: URL of the engine that will be started. Should take\n            the form `{protocol}://{host}:{port}`.\n    \"\"\"\n    server_engine = Engine(url)\n    server_engine.on_finalize(_when_finalize)\n    server_engine.enable_remote_shutdown()\n\n    receiver = MargoServer(server_engine)\n    server_engine.register('evict', receiver.evict)\n    server_engine.register('exists', receiver.exists)\n    server_engine.register('get', receiver.get)\n    server_engine.register('put', receiver.put)\n    server_engine.wait_for_finalize()\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.spawn_server","title":"spawn_server()","text":"<pre><code>spawn_server(\n    protocol: str,\n    address: str,\n    port: int,\n    *,\n    spawn_timeout: float = 5.0,\n    kill_timeout: float | None = 1.0\n) -&gt; multiprocessing.context.SpawnProcess\n</code></pre> <p>Spawn a local server running in a separate process.</p> Note <p>An <code>atexit</code> callback is registered which will terminate the spawned server process when the calling process exits.</p> <p>Parameters:</p> <ul> <li> <code>protocol</code>             (<code>str</code>)         \u2013          <p>Communication protocol.</p> </li> <li> <code>address</code>             (<code>str</code>)         \u2013          <p>Host IP of the server to wait on.</p> </li> <li> <code>port</code>             (<code>int</code>)         \u2013          <p>Port of the server to wait on.</p> </li> <li> <code>spawn_timeout</code>             (<code>float</code>, default:                 <code>5.0</code> )         \u2013          <p>Max time in seconds to wait for the server to start.</p> </li> <li> <code>kill_timeout</code>             (<code>float | None</code>, default:                 <code>1.0</code> )         \u2013          <p>Max time in seconds to wait for the server to shutdown on exit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SpawnProcess</code>         \u2013          <p>The process that the server is running in.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def spawn_server(\n    protocol: str,\n    address: str,\n    port: int,\n    *,\n    spawn_timeout: float = 5.0,\n    kill_timeout: float | None = 1.0,\n) -&gt; multiprocessing.context.SpawnProcess:\n    \"\"\"Spawn a local server running in a separate process.\n\n    Note:\n        An `atexit` callback is registered which will terminate the spawned\n        server process when the calling process exits.\n\n    Args:\n        protocol: Communication protocol.\n        address: Host IP of the server to wait on.\n        port: Port of the server to wait on.\n        spawn_timeout: Max time in seconds to wait for the server to start.\n        kill_timeout: Max time in seconds to wait for the server to shutdown\n            on exit.\n\n    Returns:\n        The process that the server is running in.\n    \"\"\"\n    url = f'{protocol}://{address}:{port}'\n\n    ctx = multiprocessing.get_context('spawn')\n    server_process = ctx.Process(\n        target=start_server,\n        args=(url,),\n    )\n    server_process.start()\n\n    def _kill_on_exit() -&gt; None:  # pragma: no cover\n        if server_process.is_alive():\n            server_process.terminate()\n            server_process.join(timeout=kill_timeout)\n            if server_process.is_alive():\n                server_process.kill()\n                server_process.join()\n            logger.debug(\n                'Server terminated on parent process exit '\n                f'(pid={server_process.pid})',\n            )\n\n    atexit.register(_kill_on_exit)\n    logger.debug('Registered server cleanup atexit callback')\n\n    wait_for_server(protocol, address, port, timeout=spawn_timeout)\n    logger.debug(\n        f'Server started (address={url}, pid={server_process.pid})',\n    )\n\n    return server_process\n</code></pre>"},{"location":"api/connectors/dim/margo/#proxystore_ex.connectors.dim.margo.wait_for_server","title":"wait_for_server()","text":"<pre><code>wait_for_server(\n    protocol: str,\n    address: str,\n    port: int,\n    timeout: float = 0.1,\n) -&gt; None\n</code></pre> <p>Wait until the server responds.</p> Warning <p>Due to how Margo blocks internally, the timeout is not very accurate.</p> <p>Parameters:</p> <ul> <li> <code>protocol</code>             (<code>str</code>)         \u2013          <p>Communication protocol.</p> </li> <li> <code>address</code>             (<code>str</code>)         \u2013          <p>Host IP of the server to wait on.</p> </li> <li> <code>port</code>             (<code>int</code>)         \u2013          <p>Port of the server to wait on.</p> </li> <li> <code>timeout</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>The max time in seconds to wait for server response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServerTimeoutError</code>           \u2013          <p>If the server does not respond within the timeout.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/margo.py</code> <pre><code>def wait_for_server(\n    protocol: str,\n    address: str,\n    port: int,\n    timeout: float = 0.1,\n) -&gt; None:\n    \"\"\"Wait until the server responds.\n\n    Warning:\n        Due to how Margo blocks internally, the timeout is not very accurate.\n\n    Args:\n        protocol: Communication protocol.\n        address: Host IP of the server to wait on.\n        port: Port of the server to wait on.\n        timeout: The max time in seconds to wait for server response.\n\n    Raises:\n        ServerTimeoutError: If the server does not respond within the timeout.\n    \"\"\"\n    engine = Engine(protocol, mode=pymargo.client, use_progress_thread=True)\n    remote_function = engine.register('exists')\n    key = DIMKey(\n        'margo',\n        obj_id='ping',\n        size=0,\n        peer_host=address,\n        peer_port=port,\n    )\n    rpc = RPC('exists', key=key)\n    url = f'{protocol}://{address}:{port}'\n\n    sleep_time = 0.01\n    start = time.time()\n    while time.time() - start &lt; timeout:\n        try:\n            local_url = engine.lookup(url)\n            result = remote_function.on(local_url)(\n                rpc.data,\n                rpc.key.size,\n                rpc.key,\n            )\n            response = deserialize(result)\n            assert response.exception is None\n            # We could call engine.finalize() now to be safe but Margo\n            # raises a _pymargo.MargoException: margo_addr_free() returned 11\n            # exception.\n            return\n        except MargoException:  # pragma: no cover\n            time.sleep(sleep_time)\n\n    raise ServerTimeoutError(\n        f'Failed to connect to server within timeout ({timeout} seconds).',\n    )\n</code></pre>"},{"location":"api/connectors/dim/models/","title":"proxystore_ex.connectors.dim.models","text":"<code>proxystore_ex/connectors/dim/models.py</code> <p>Message types for communication with DIM servers.</p>"},{"location":"api/connectors/dim/models/#proxystore_ex.connectors.dim.models.DIMKey","title":"DIMKey","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Key to objects stored across <code>UCXConnector</code>s.</p> <p>Attributes:</p> <ul> <li> <code>dim_type</code>             (<code>Literal['margo', 'ucx', 'zmq']</code>)         \u2013          <p>Type of DIM this key belongs to.</p> </li> <li> <code>obj_id</code>             (<code>str</code>)         \u2013          <p>Unique object key.</p> </li> <li> <code>size</code>             (<code>int</code>)         \u2013          <p>Object size in bytes.</p> </li> <li> <code>peer_host</code>             (<code>str</code>)         \u2013          <p>Hostname of peer where object is located.</p> </li> <li> <code>peer_port</code>             (<code>int</code>)         \u2013          <p>Port of peer server where object is located.</p> </li> </ul>"},{"location":"api/connectors/dim/models/#proxystore_ex.connectors.dim.models.RPC","title":"RPC  <code>dataclass</code>","text":"<p>Client request to a DIM server.</p> <p>Attributes:</p> <ul> <li> <code>operation</code>             (<code>Literal['exists', 'evict', 'get', 'put']</code>)         \u2013          <p>Operation type requested.</p> </li> <li> <code>key</code>             (<code>DIMKey</code>)         \u2013          <p>Key to operate on.</p> </li> <li> <code>size</code>             (<code>DIMKey</code>)         \u2013          <p>Size of data associated with key.</p> </li> <li> <code>data</code>             (<code>bytes | None</code>)         \u2013          <p>Data associated with <code>set</code> operation.</p> </li> </ul>"},{"location":"api/connectors/dim/models/#proxystore_ex.connectors.dim.models.RPCResponse","title":"RPCResponse  <code>dataclass</code>","text":"<p>Server response to a client request.</p> <p>Attributes:</p> <ul> <li> <code>operation</code>             (<code>Literal['exists', 'evict', 'get', 'put']</code>)         \u2013          <p>Operation type performed.</p> </li> <li> <code>key</code>             (<code>DIMKey</code>)         \u2013          <p>Key that was operated on.</p> </li> <li> <code>size</code>             (<code>DIMKey</code>)         \u2013          <p>Size of data associated with key.</p> </li> <li> <code>data</code>             (<code>bytes | None</code>)         \u2013          <p>Data returned by <code>get</code> operation.</p> </li> <li> <code>exists</code>             (<code>bool | None</code>)         \u2013          <p>Return value for <code>exists</code> operation.</p> </li> <li> <code>exception</code>             (<code>Exception | None</code>)         \u2013          <p>Optional exception raised by the operation.</p> </li> </ul>"},{"location":"api/connectors/dim/ucx/","title":"proxystore_ex.connectors.dim.ucx","text":"<code>proxystore_ex/connectors/dim/ucx.py</code> <p>UCX-based distributed in-memory connector implementation.</p>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXConnector","title":"UCXConnector","text":"<pre><code>UCXConnector(\n    port: int,\n    address: str | None = None,\n    interface: str | None = None,\n    timeout: float = 1,\n)\n</code></pre> <p>UCX-based distributed in-memory connector.</p> Note <p>The first instance of this connector created on a process will spawn a <code>UCXServer</code> that will store data. Hence, this connector just acts as an interface to that server.</p> <p>Parameters:</p> <ul> <li> <code>port</code>             (<code>int</code>)         \u2013          <p>The desired port for the spawned server.</p> </li> <li> <code>address</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The IP address of the network interface to use. Has precedence over <code>interface</code> if both are provided.</p> </li> <li> <code>interface</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The network interface to use. <code>address</code> has precedence if both args are defined.</p> </li> <li> <code>timeout</code>             (<code>float</code>, default:                 <code>1</code> )         \u2013          <p>Timeout in seconds to try connecting to local server before spawning one.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServerTimeoutError</code>           \u2013          <p>If a local server cannot be connected to within <code>timeout</code> seconds, and a new local server does not response within <code>timeout</code> seconds after being started.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def __init__(\n    self,\n    port: int,\n    address: str | None = None,\n    interface: str | None = None,\n    timeout: float = 1,\n) -&gt; None:\n    if ucx_import_error is not None:  # pragma: no cover\n        raise ucx_import_error\n\n    self._address = address\n    self._interface = interface\n    self.port = port\n    self.timeout = timeout\n\n    if self._address is not None:\n        self.address = self._address\n    elif self._interface is not None:\n        self.address = ucp.get_address(ifname=self._interface)\n    else:\n        self.address = ucp.get_address()\n\n    self.url = f'{self.address}:{self.port}'\n\n    self.server: multiprocessing.context.SpawnProcess | None\n    try:\n        logger.info(\n            f'Connecting to local server (URL={self.url})...',\n        )\n        wait_for_server(self.address, self.port, self.timeout)\n        logger.info(\n            f'Connected to local server (URL={self.url})',\n        )\n    except ServerTimeoutError:\n        logger.info(\n            'Failed to connect to local server '\n            f'(URL={self.url}, timeout={self.timeout})',\n        )\n        self.server = spawn_server(\n            self.address,\n            self.port,\n            spawn_timeout=self.timeout,\n        )\n        logger.info(f'Spawned local server (address={self.url})')\n    else:\n        self.server = None\n\n    try:\n        self._loop = asyncio.get_running_loop()\n    except RuntimeError:\n        self._loop = asyncio.new_event_loop()\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXConnector.close","title":"close()","text":"<pre><code>close(kill_server: bool = False) -&gt; None\n</code></pre> <p>Close the connector.</p> <p>Parameters:</p> <ul> <li> <code>kill_server</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to kill the server process. If this instance did not spawn the local node's server process, this is a no-op.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def close(self, kill_server: bool = False) -&gt; None:\n    \"\"\"Close the connector.\n\n    Args:\n        kill_server: Whether to kill the server process. If this instance\n            did not spawn the local node's server process, this is a\n            no-op.\n    \"\"\"\n    if kill_server and self.server is not None:\n        self.server.terminate()\n        self.server.join()\n        logger.info(\n            'Terminated local server on connector close '\n            f'(pid={self.server.pid})',\n        )\n\n    logger.debug('Closed UCX connector')\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the connector configuration.\n\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\n    return {\n        'address': self._address,\n        'interface': self._interface,\n        'port': self.port,\n        'timeout': self.timeout,\n    }\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; UCXConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>dict[str, Any]</code>)         \u2013          <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; UCXConnector:\n    \"\"\"Create a new connector instance from a configuration.\n\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\n    return cls(**config)\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXConnector.evict","title":"evict()","text":"<pre><code>evict(key: DIMKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>DIMKey</code>)         \u2013          <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def evict(self, key: DIMKey) -&gt; None:\n    \"\"\"Evict the object associated with the key.\n\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\n    rpc = RPC(operation='evict', key=key)\n    self._send_rpcs([rpc])\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXConnector.exists","title":"exists()","text":"<pre><code>exists(key: DIMKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>DIMKey</code>)         \u2013          <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def exists(self, key: DIMKey) -&gt; bool:\n    \"\"\"Check if an object associated with the key exists.\n\n    Args:\n        key: Key potentially associated with stored object.\n\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\n    rpc = RPC(operation='exists', key=key)\n    (response,) = self._send_rpcs([rpc])\n    assert response.exists is not None\n    return response.exists\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXConnector.get","title":"get()","text":"<pre><code>get(key: DIMKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>DIMKey</code>)         \u2013          <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013          <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def get(self, key: DIMKey) -&gt; bytes | None:\n    \"\"\"Get the serialized object associated with the key.\n\n    Args:\n        key: Key associated with the object to retrieve.\n\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\n    rpc = RPC(operation='get', key=key)\n    (result,) = self._send_rpcs([rpc])\n    return result.data\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[DIMKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> <code>keys</code>             (<code>Sequence[DIMKey]</code>)         \u2013          <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013          <p>List with same order as <code>keys</code> with the serialized objects or             <code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def get_batch(self, keys: Sequence[DIMKey]) -&gt; list[bytes | None]:\n    \"\"\"Get a batch of serialized objects associated with the keys.\n\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n\n    Returns:\n        List with same order as `keys` with the serialized objects or \\\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\n    rpcs = [RPC(operation='get', key=key) for key in keys]\n    responses = self._send_rpcs(rpcs)\n    return [r.data for r in responses]\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; DIMKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>             (<code>bytes</code>)         \u2013          <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DIMKey</code>         \u2013          <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def put(self, obj: bytes) -&gt; DIMKey:\n    \"\"\"Put a serialized object in the store.\n\n    Args:\n        obj: Serialized object to put in the store.\n\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\n    key = DIMKey(\n        dim_type='ucx',\n        obj_id=str(uuid.uuid4()),\n        size=len(obj),\n        peer_host=self.address,\n        peer_port=self.port,\n    )\n    rpc = RPC(operation='put', key=key, data=obj)\n    self._send_rpcs([rpc])\n    return key\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[DIMKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> <code>objs</code>             (<code>Sequence[bytes]</code>)         \u2013          <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DIMKey]</code>         \u2013          <p>List of keys with the same order as <code>objs</code> which can be used to             retrieve the objects.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[DIMKey]:\n    \"\"\"Put a batch of serialized objects in the store.\n\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n\n    Returns:\n        List of keys with the same order as `objs` which can be used to \\\n        retrieve the objects.\n    \"\"\"\n    keys = [\n        DIMKey(\n            dim_type='ucx',\n            obj_id=str(uuid.uuid4()),\n            size=len(obj),\n            peer_host=self.address,\n            peer_port=self.port,\n        )\n        for obj in objs\n    ]\n    rpcs = [\n        RPC(operation='put', key=key, data=obj)\n        for key, obj in zip(keys, objs)\n    ]\n    self._send_rpcs(rpcs)\n    return keys\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXServer","title":"UCXServer","text":"<pre><code>UCXServer()\n</code></pre> <p>UCXServer implementation.</p> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.data: dict[str, bytes] = {}\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXServer.evict","title":"evict()","text":"<pre><code>evict(key: str) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def evict(self, key: str) -&gt; None:\n    \"\"\"Evict the object associated with the key.\n\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\n    self.data.pop(key, None)\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXServer.exists","title":"exists()","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def exists(self, key: str) -&gt; bool:\n    \"\"\"Check if an object associated with the key exists.\n\n    Args:\n        key: Key potentially associated with stored object.\n\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\n    return key in self.data\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXServer.get","title":"get()","text":"<pre><code>get(key: str) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013          <p>Data or <code>None</code> if no data associated with the key exists.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def get(self, key: str) -&gt; bytes | None:\n    \"\"\"Get the serialized object associated with the key.\n\n    Args:\n        key: Key associated with the object to retrieve.\n\n    Returns:\n        Data or `None` if no data associated with the key exists.\n    \"\"\"\n    return self.data.get(key, None)\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXServer.put","title":"put()","text":"<pre><code>put(key: str, data: bytes) -&gt; None\n</code></pre> <p>Put data in the store.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>Key associated with data.</p> </li> <li> <code>data</code>             (<code>bytes</code>)         \u2013          <p>Data to put in the store.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def put(self, key: str, data: bytes) -&gt; None:\n    \"\"\"Put data in the store.\n\n    Args:\n        key: Key associated with data.\n        data: Data to put in the store.\n    \"\"\"\n    self.data[key] = data\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXServer.handle_rpc","title":"handle_rpc()","text":"<pre><code>handle_rpc(rpc: RPC) -&gt; RPCResponse\n</code></pre> <p>Process an RPC request.</p> <p>Parameters:</p> <ul> <li> <code>rpc</code>             (<code>RPC</code>)         \u2013          <p>Client RPC to process.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RPCResponse</code>         \u2013          <p>Response containing result or an exception if the operation failed.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def handle_rpc(self, rpc: RPC) -&gt; RPCResponse:\n    \"\"\"Process an RPC request.\n\n    Args:\n        rpc: Client RPC to process.\n\n    Returns:\n        Response containing result or an exception if the operation failed.\n    \"\"\"\n    response: RPCResponse\n\n    try:\n        if rpc.operation == 'exists':\n            exists = self.exists(rpc.key.obj_id)\n            response = RPCResponse('exists', key=rpc.key, exists=exists)\n        elif rpc.operation == 'evict':\n            self.evict(rpc.key.obj_id)\n            response = RPCResponse('evict', key=rpc.key)\n        elif rpc.operation == 'get':\n            data = self.get(rpc.key.obj_id)\n            response = RPCResponse('get', key=rpc.key, data=data)\n        elif rpc.operation == 'put':\n            assert rpc.data is not None\n            self.put(rpc.key.obj_id, rpc.data)\n            response = RPCResponse('put', key=rpc.key)\n        else:\n            raise AssertionError('Unreachable.')\n    except Exception as e:\n        response = RPCResponse(rpc.operation, key=rpc.key, exception=e)\n    return response\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.UCXServer.handler","title":"handler()  <code>async</code>","text":"<pre><code>handler(ep: ucp.Endpoint) -&gt; None\n</code></pre> <p>Handle endpoint requests.</p> <p>Parameters:</p> <ul> <li> <code>ep</code>             (<code>Endpoint</code>)         \u2013          <p>The endpoint making the request.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>async def handler(self, ep: ucp.Endpoint) -&gt; None:\n    \"\"\"Handle endpoint requests.\n\n    Args:\n        ep: The endpoint making the request.\n    \"\"\"\n    rpc_bytes = bytes(await ep.recv_obj())\n\n    if rpc_bytes == b'ping':\n        await ep.send_obj(b'pong')\n        return\n\n    rpc: RPC = deserialize(rpc_bytes)\n    response = self.handle_rpc(rpc)\n\n    message = serialize(response)\n    await ep.send_obj(message)\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.run_server","title":"run_server()  <code>async</code>","text":"<pre><code>run_server(port: int) -&gt; None\n</code></pre> <p>Listen and reply to RPCs from clients.</p> Warning <p>This function does not return until SIGINT or SIGTERM is received.</p> <p>Parameters:</p> <ul> <li> <code>port</code>             (<code>int</code>)         \u2013          <p>Port the server should listen on.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>async def run_server(port: int) -&gt; None:  # pragma: no cover\n    \"\"\"Listen and reply to RPCs from clients.\n\n    Warning:\n        This function does not return until SIGINT or SIGTERM is received.\n\n    Args:\n        port: Port the server should listen on.\n    \"\"\"\n    server = UCXServer()\n    ucp_listener = ucp.create_listener(server.handler, port)\n\n    loop = asyncio.get_running_loop()\n    close_future = loop.create_future()\n    loop.add_signal_handler(signal.SIGINT, close_future.set_result, None)\n    loop.add_signal_handler(signal.SIGTERM, close_future.set_result, None)\n\n    await close_future\n    ucp_listener.close()\n\n    while not ucp_listener.closed():\n        await asyncio.sleep(0.001)\n\n    loop.remove_signal_handler(signal.SIGINT)\n    loop.remove_signal_handler(signal.SIGTERM)\n\n    # UCP does reference counting of open resources\n    del ucp_listener\n    await reset_ucp_async()\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.start_server","title":"start_server()","text":"<pre><code>start_server(port: int) -&gt; None\n</code></pre> <p>Run a local server.</p> Note <p>This function creates an event loop and executes <code>run_server()</code> within that loop.</p> <p>Parameters:</p> <ul> <li> <code>port</code>             (<code>int</code>)         \u2013          <p>Port the server should listen on.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def start_server(port: int) -&gt; None:  # pragma: no cover\n    \"\"\"Run a local server.\n\n    Note:\n        This function creates an event loop and executes\n        [`run_server()`][proxystore_ex.connectors.dim.ucx.run_server] within\n        that loop.\n\n    Args:\n        port: Port the server should listen on.\n    \"\"\"\n    asyncio.run(run_server(port))\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.spawn_server","title":"spawn_server()","text":"<pre><code>spawn_server(\n    address: str,\n    port: int,\n    *,\n    spawn_timeout: float = 5.0,\n    kill_timeout: float | None = 1.0\n) -&gt; multiprocessing.context.SpawnProcess\n</code></pre> <p>Spawn a local server running in a separate process.</p> Note <p>An <code>atexit</code> callback is registered which will terminate the spawned server process when the calling process exits.</p> <p>Parameters:</p> <ul> <li> <code>address</code>             (<code>str</code>)         \u2013          <p>IP address the server will listen on.</p> </li> <li> <code>port</code>             (<code>int</code>)         \u2013          <p>Port the server will listen on.</p> </li> <li> <code>spawn_timeout</code>             (<code>float</code>, default:                 <code>5.0</code> )         \u2013          <p>Max time in seconds to wait for the server to start.</p> </li> <li> <code>kill_timeout</code>             (<code>float | None</code>, default:                 <code>1.0</code> )         \u2013          <p>Max time in seconds to wait for the server to shutdown on exit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SpawnProcess</code>         \u2013          <p>The process that the server is running in.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def spawn_server(\n    address: str,\n    port: int,\n    *,\n    spawn_timeout: float = 5.0,\n    kill_timeout: float | None = 1.0,\n) -&gt; multiprocessing.context.SpawnProcess:\n    \"\"\"Spawn a local server running in a separate process.\n\n    Note:\n        An `atexit` callback is registered which will terminate the spawned\n        server process when the calling process exits.\n\n    Args:\n        address: IP address the server will listen on.\n        port: Port the server will listen on.\n        spawn_timeout: Max time in seconds to wait for the server to start.\n        kill_timeout: Max time in seconds to wait for the server to shutdown\n            on exit.\n\n    Returns:\n        The process that the server is running in.\n    \"\"\"\n    ctx = multiprocessing.get_context('spawn')\n    # UCX seems to hang if you fork a process after calling ucp.init().\n    # If discovered this via a comment in Dask's distributed communication:\n    # https://github.com/dask/distributed/blob/76bbfaf9f4a14906cbf4500ed42c442c7a5bc971/distributed/comm/ucx.py#L40  # noqa: E501\n    server_process = ctx.Process(\n        target=start_server,\n        args=(port,),\n    )\n    server_process.start()\n\n    def _kill_on_exit() -&gt; None:  # pragma: no cover\n        server_process.terminate()\n        server_process.join(timeout=kill_timeout)\n        if server_process.is_alive():\n            server_process.kill()\n            server_process.join()\n        logger.debug(\n            'Server terminated on parent process exit '\n            f'(pid={server_process.pid})',\n        )\n\n    atexit.register(_kill_on_exit)\n    logger.debug('Registered server cleanup atexit callback')\n\n    wait_for_server(address, port, timeout=spawn_timeout)\n    logger.debug(\n        f'Server started (host={address}, port={port}, pid={server_process.pid})',\n    )\n\n    return server_process\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.wait_for_server_async","title":"wait_for_server_async()  <code>async</code>","text":"<pre><code>wait_for_server_async(\n    address: str, port: int, timeout: float = 0.1\n) -&gt; None\n</code></pre> <p>Wait until the server responds.</p> <p>Parameters:</p> <ul> <li> <code>address</code>             (<code>str</code>)         \u2013          <p>Host IP of the server to ping.</p> </li> <li> <code>port</code>             (<code>int</code>)         \u2013          <p>Port of the server to ping.</p> </li> <li> <code>timeout</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>Max time in seconds to wait for server response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServerTimeoutError</code>           \u2013          <p>If the server does not respond within the timeout.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>async def wait_for_server_async(\n    address: str,\n    port: int,\n    timeout: float = 0.1,\n) -&gt; None:\n    \"\"\"Wait until the server responds.\n\n    Args:\n        address: Host IP of the server to ping.\n        port: Port of the server to ping.\n        timeout: Max time in seconds to wait for server response.\n\n    Raises:\n        ServerTimeoutError: If the server does not respond within the timeout.\n    \"\"\"\n    sleep_time = 0.01\n    time_waited = 0.0\n\n    while True:\n        try:\n            ep = await ucp.create_endpoint(address, port)\n        except ucp._libs.exceptions.UCXNotConnected as e:  # pragma: no cover\n            if time_waited &gt;= timeout:\n                raise ServerTimeoutError(\n                    'Failed to connect to server within timeout '\n                    f'({timeout} seconds).',\n                ) from e\n            await asyncio.sleep(sleep_time)\n            time_waited += sleep_time\n        else:\n            break  # pragma: no cover\n\n    await ep.send_obj(b'ping')\n    assert bytes(await ep.recv_obj()) == b'pong'\n    await ep.close()\n    assert ep.closed()\n    del ep\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.wait_for_server","title":"wait_for_server()","text":"<pre><code>wait_for_server(\n    address: str, port: int, timeout: float = 0.1\n) -&gt; None\n</code></pre> <p>Wait until the server responds.</p> Note <p>This function calls <code>wait_for_server_async()</code> using <code>asyncio.run()</code>.</p> <p>Parameters:</p> <ul> <li> <code>address</code>             (<code>str</code>)         \u2013          <p>The host IP of the server to ping.</p> </li> <li> <code>port</code>             (<code>int</code>)         \u2013          <p>Theport of the server to ping.</p> </li> <li> <code>timeout</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>The max time in seconds to wait for server response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServerTimeoutError</code>           \u2013          <p>If the server does not respond within the timeout.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>def wait_for_server(address: str, port: int, timeout: float = 0.1) -&gt; None:\n    \"\"\"Wait until the server responds.\n\n    Note:\n        This function calls\n        [`wait_for_server_async()`][proxystore_ex.connectors.dim.ucx.wait_for_server_async]\n        using [`asyncio.run()`][asyncio.run].\n\n    Args:\n        address: The host IP of the server to ping.\n        port: Theport of the server to ping.\n        timeout: The max time in seconds to wait for server response.\n\n    Raises:\n        ServerTimeoutError: If the server does not respond within the timeout.\n    \"\"\"\n    asyncio.run(wait_for_server_async(address, port, timeout))\n</code></pre>"},{"location":"api/connectors/dim/ucx/#proxystore_ex.connectors.dim.ucx.reset_ucp_async","title":"reset_ucp_async()  <code>async</code>","text":"<pre><code>reset_ucp_async(reset_ucp: bool = True) -&gt; None\n</code></pre> <p>Hard reset all of UCP.</p> <p>UCP provides <code>ucp.reset()</code>; however, this function does not correctly shutdown all asyncio tasks and readers. This function wraps <code>ucp.reset()</code> and additionally removes all readers on the event loop and cancels/awaits all asyncio tasks.</p> Source code in <code>proxystore_ex/connectors/dim/ucx.py</code> <pre><code>async def reset_ucp_async(reset_ucp: bool = True) -&gt; None:  # pragma: no cover\n    \"\"\"Hard reset all of UCP.\n\n    UCP provides `ucp.reset()`; however, this function does not correctly\n    shutdown all asyncio tasks and readers. This function wraps\n    `ucp.reset()` and additionally removes all readers on the event loop\n    and cancels/awaits all asyncio tasks.\n    \"\"\"\n\n    async def inner_context() -&gt; None:\n        ctx = ucp.core._get_ctx()\n\n        for task in ctx.progress_tasks:\n            if task is None:\n                continue\n            task.event_loop.remove_reader(ctx.epoll_fd)\n            if task.asyncio_task is not None:\n                try:\n                    task.asyncio_task.cancel()\n                    await task.asyncio_task\n                # A RuntimeError can happen if the task if from a different\n                # event loop. We'll just skip these for now\n                except (asyncio.CancelledError, RuntimeError):\n                    pass\n\n    # We access ucp.core._get_ctx() inside this nested function so our local\n    # reference to the UCP context goes out of scope before calling\n    # ucp.reset(). ucp.reset() will fail if there are any weak references to\n    # to the UCP context because it assumes those may be Listeners or\n    # Endpoints that were not properly closed.\n    await inner_context()\n\n    if reset_ucp:\n        try:\n            ucp.reset()\n        except ucp.UCXError:\n            pass\n</code></pre>"},{"location":"api/connectors/dim/utils/","title":"proxystore_ex.connectors.dim.utils","text":"<code>proxystore_ex/connectors/dim/utils.py</code> <p>Shared functions used by DIM stores.</p>"},{"location":"api/connectors/dim/utils/#proxystore_ex.connectors.dim.utils.get_ip_address","title":"get_ip_address()","text":"<pre><code>get_ip_address(ifname: str) -&gt; str\n</code></pre> <p>Get ip address provided an interface name.</p> Warning <p>This function does not work on MacOS/Darwin.</p> <p>Parameters:</p> <ul> <li> <code>ifname</code>             (<code>str</code>)         \u2013          <p>The interface name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The IP address.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/utils.py</code> <pre><code>def get_ip_address(ifname: str) -&gt; str:  # pragma: darwin no cover\n    \"\"\"Get ip address provided an interface name.\n\n    Warning:\n        This function does not work on MacOS/Darwin.\n\n    Args:\n        ifname: The interface name.\n\n    Returns:\n        The IP address.\n    \"\"\"\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    return socket.inet_ntoa(\n        fcntl.ioctl(\n            s.fileno(),\n            0x8915,\n            struct.pack(\n                '256s',\n                bytes(ifname[:15], 'utf-8'),\n            ),  # SIOCGIFADDR\n        )[20:24],\n    )\n</code></pre>"},{"location":"api/connectors/dim/zmq/","title":"proxystore_ex.connectors.dim.zmq","text":"<code>proxystore_ex/connectors/dim/zmq.py</code> <p>ZeroMQ-based distributed in-memory connector implementation.</p>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQConnector","title":"ZeroMQConnector","text":"<pre><code>ZeroMQConnector(\n    port: int,\n    address: str | None = None,\n    interface: str | None = None,\n    chunk_length: int | None = None,\n    timeout: float = 1,\n)\n</code></pre> <p>ZeroMQ-based distributed in-memory connector.</p> Note <p>The first instance of this connector created on a process will spawn a <code>ZeroMQServer</code> that will store data. Hence, this connector just acts as an interface to that server.</p> <p>Parameters:</p> <ul> <li> <code>address</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The network IP address to use. Takes precedence over <code>interface</code> if both are provided.</p> </li> <li> <code>interface</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The network interface to use. <code>address</code> arg takes precedence if both are provided.</p> </li> <li> <code>port</code>             (<code>int</code>)         \u2013          <p>The desired port for the spawned server.</p> </li> <li> <code>chunk_length</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Message chunk size in bytes. Defaults to <code>MAX_CHUNK_LENGTH_DEFAULT</code>.</p> </li> <li> <code>timeout</code>             (<code>float</code>, default:                 <code>1</code> )         \u2013          <p>Timeout in seconds to try connecting to local server before spawning one.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServerTimeoutError</code>           \u2013          <p>If a local server cannot be connected to within <code>timeout</code> seconds, and a new local server does not response within <code>timeout</code> seconds after being started.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def __init__(\n    self,\n    port: int,\n    address: str | None = None,\n    interface: str | None = None,\n    chunk_length: int | None = None,\n    timeout: float = 1,\n) -&gt; None:\n    # ZMQ is not a default dependency so we don't want to raise\n    # an error unless the user actually tries to use this code\n    if zmq_import_error is not None:  # pragma: no cover\n        raise zmq_import_error\n\n    self._address = address\n    self._interface = interface\n    self.port = port\n    self.chunk_length = (\n        MAX_CHUNK_LENGTH_DEFAULT if chunk_length is None else chunk_length\n    )\n    self.timeout = timeout\n\n    if self._address is not None:\n        self.address = self._address\n    elif self._interface is not None:  # pragma: darwin no cover\n        self.address = get_ip_address(self._interface)\n    else:\n        host = socket.gethostname()\n        self.address = socket.gethostbyname(host)\n\n    self.url = f'tcp://{self.address}:{self.port}'\n\n    self.server: multiprocessing.Process | None\n    try:\n        logger.info(\n            f'Connecting to local server (url={self.url})...',\n        )\n        wait_for_server(self.address, self.port, self.timeout)\n        logger.info(\n            f'Connected to local server (url={self.url})',\n        )\n    except ServerTimeoutError:\n        logger.info(\n            'Failed to connect to local server '\n            f'(address={self.url}, timeout={self.timeout})',\n        )\n        self.server = spawn_server(\n            self.address,\n            self.port,\n            chunk_length=self.chunk_length,\n            spawn_timeout=self.timeout,\n        )\n        logger.info(f'Spawned local server (url={self.url})')\n    else:\n        self.server = None\n\n    self.context = zmq.Context()\n    self.socket = self.context.socket(zmq.REQ)\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQConnector.close","title":"close()","text":"<pre><code>close(kill_server: bool = True) -&gt; None\n</code></pre> <p>Close the connector.</p> <p>Parameters:</p> <ul> <li> <code>kill_server</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to kill the server process. If this instance did not spawn the local node's server process, this is a no-op.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def close(self, kill_server: bool = True) -&gt; None:\n    \"\"\"Close the connector.\n\n    Args:\n        kill_server: Whether to kill the server process. If this instance\n            did not spawn the local node's server process, this is a\n            no-op.\n    \"\"\"\n    if kill_server and self.server is not None:\n        self.server.terminate()\n        self.server.join()\n        logger.info(\n            'Terminated local server on connector close '\n            f'(pid={self.server.pid})',\n        )\n\n    self.socket.close()\n    self.context.term()\n    logger.info('Closed ZMQ connector')\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQConnector.config","title":"config()","text":"<pre><code>config() -&gt; dict[str, Any]\n</code></pre> <p>Get the connector configuration.</p> <p>The configuration contains all the information needed to reconstruct the connector object.</p> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the connector configuration.\n\n    The configuration contains all the information needed to reconstruct\n    the connector object.\n    \"\"\"\n    return {\n        'address': self._address,\n        'interface': self._interface,\n        'port': self.port,\n        'chunk_length': self.chunk_length,\n        'timeout': self.timeout,\n    }\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQConnector.from_config","title":"from_config()  <code>classmethod</code>","text":"<pre><code>from_config(config: dict[str, Any]) -&gt; ZeroMQConnector\n</code></pre> <p>Create a new connector instance from a configuration.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>dict[str, Any]</code>)         \u2013          <p>Configuration returned by <code>.config()</code>.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>@classmethod\ndef from_config(cls, config: dict[str, Any]) -&gt; ZeroMQConnector:\n    \"\"\"Create a new connector instance from a configuration.\n\n    Args:\n        config: Configuration returned by `#!python .config()`.\n    \"\"\"\n    return cls(**config)\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQConnector.evict","title":"evict()","text":"<pre><code>evict(key: DIMKey) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>DIMKey</code>)         \u2013          <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def evict(self, key: DIMKey) -&gt; None:\n    \"\"\"Evict the object associated with the key.\n\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\n    rpc = RPC(operation='evict', key=key)\n    self._send_rpcs([rpc])\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQConnector.exists","title":"exists()","text":"<pre><code>exists(key: DIMKey) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>DIMKey</code>)         \u2013          <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def exists(self, key: DIMKey) -&gt; bool:\n    \"\"\"Check if an object associated with the key exists.\n\n    Args:\n        key: Key potentially associated with stored object.\n\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\n    rpc = RPC(operation='exists', key=key)\n    (response,) = self._send_rpcs([rpc])\n    assert response.exists is not None\n    return response.exists\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQConnector.get","title":"get()","text":"<pre><code>get(key: DIMKey) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>DIMKey</code>)         \u2013          <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013          <p>Serialized object or <code>None</code> if the object does not exist.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def get(self, key: DIMKey) -&gt; bytes | None:\n    \"\"\"Get the serialized object associated with the key.\n\n    Args:\n        key: Key associated with the object to retrieve.\n\n    Returns:\n        Serialized object or `None` if the object does not exist.\n    \"\"\"\n    rpc = RPC(operation='get', key=key)\n    (result,) = self._send_rpcs([rpc])\n    return result.data\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQConnector.get_batch","title":"get_batch()","text":"<pre><code>get_batch(keys: Sequence[DIMKey]) -&gt; list[bytes | None]\n</code></pre> <p>Get a batch of serialized objects associated with the keys.</p> <p>Parameters:</p> <ul> <li> <code>keys</code>             (<code>Sequence[DIMKey]</code>)         \u2013          <p>Sequence of keys associated with objects to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[bytes | None]</code>         \u2013          <p>List with same order as <code>keys</code> with the serialized objects or             <code>None</code> if the corresponding key does not have an associated object.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def get_batch(self, keys: Sequence[DIMKey]) -&gt; list[bytes | None]:\n    \"\"\"Get a batch of serialized objects associated with the keys.\n\n    Args:\n        keys: Sequence of keys associated with objects to retrieve.\n\n    Returns:\n        List with same order as `keys` with the serialized objects or \\\n        `None` if the corresponding key does not have an associated object.\n    \"\"\"\n    rpcs = [RPC(operation='get', key=key) for key in keys]\n    responses = self._send_rpcs(rpcs)\n    return [r.data for r in responses]\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQConnector.put","title":"put()","text":"<pre><code>put(obj: bytes) -&gt; DIMKey\n</code></pre> <p>Put a serialized object in the store.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>             (<code>bytes</code>)         \u2013          <p>Serialized object to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DIMKey</code>         \u2013          <p>Key which can be used to retrieve the object.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def put(self, obj: bytes) -&gt; DIMKey:\n    \"\"\"Put a serialized object in the store.\n\n    Args:\n        obj: Serialized object to put in the store.\n\n    Returns:\n        Key which can be used to retrieve the object.\n    \"\"\"\n    key = DIMKey(\n        dim_type='zmq',\n        obj_id=str(uuid.uuid4()),\n        size=len(obj),\n        peer_host=self.address,\n        peer_port=self.port,\n    )\n    rpc = RPC(operation='put', key=key, data=obj)\n    self._send_rpcs([rpc])\n    return key\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQConnector.put_batch","title":"put_batch()","text":"<pre><code>put_batch(objs: Sequence[bytes]) -&gt; list[DIMKey]\n</code></pre> <p>Put a batch of serialized objects in the store.</p> <p>Parameters:</p> <ul> <li> <code>objs</code>             (<code>Sequence[bytes]</code>)         \u2013          <p>Sequence of serialized objects to put in the store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DIMKey]</code>         \u2013          <p>List of keys with the same order as <code>objs</code> which can be used to             retrieve the objects.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def put_batch(self, objs: Sequence[bytes]) -&gt; list[DIMKey]:\n    \"\"\"Put a batch of serialized objects in the store.\n\n    Args:\n        objs: Sequence of serialized objects to put in the store.\n\n    Returns:\n        List of keys with the same order as `objs` which can be used to \\\n        retrieve the objects.\n    \"\"\"\n    keys = [\n        DIMKey(\n            dim_type='zmq',\n            obj_id=str(uuid.uuid4()),\n            size=len(obj),\n            peer_host=self.address,\n            peer_port=self.port,\n        )\n        for obj in objs\n    ]\n    rpcs = [\n        RPC(operation='put', key=key, data=obj)\n        for key, obj in zip(keys, objs)\n    ]\n    self._send_rpcs(rpcs)\n    return keys\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQServer","title":"ZeroMQServer","text":"<pre><code>ZeroMQServer()\n</code></pre> <p>ZeroMQServer implementation.</p> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.data: dict[str, bytes] = {}\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQServer.evict","title":"evict()","text":"<pre><code>evict(key: str) -&gt; None\n</code></pre> <p>Evict the object associated with the key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>Key associated with object to evict.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def evict(self, key: str) -&gt; None:\n    \"\"\"Evict the object associated with the key.\n\n    Args:\n        key: Key associated with object to evict.\n    \"\"\"\n    self.data.pop(key, None)\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQServer.exists","title":"exists()","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if an object associated with the key exists.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>Key potentially associated with stored object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If an object associated with the key exists.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def exists(self, key: str) -&gt; bool:\n    \"\"\"Check if an object associated with the key exists.\n\n    Args:\n        key: Key potentially associated with stored object.\n\n    Returns:\n        If an object associated with the key exists.\n    \"\"\"\n    return key in self.data\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQServer.get","title":"get()","text":"<pre><code>get(key: str) -&gt; bytes | None\n</code></pre> <p>Get the serialized object associated with the key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>Key associated with the object to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes | None</code>         \u2013          <p>Data or <code>None</code> if no data associated with the key exists.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def get(self, key: str) -&gt; bytes | None:\n    \"\"\"Get the serialized object associated with the key.\n\n    Args:\n        key: Key associated with the object to retrieve.\n\n    Returns:\n        Data or `None` if no data associated with the key exists.\n    \"\"\"\n    return self.data.get(key, None)\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQServer.put","title":"put()","text":"<pre><code>put(key: str, data: bytes) -&gt; None\n</code></pre> <p>Put data in the store.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>Key associated with data.</p> </li> <li> <code>data</code>             (<code>bytes</code>)         \u2013          <p>Data to put in the store.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def put(self, key: str, data: bytes) -&gt; None:\n    \"\"\"Put data in the store.\n\n    Args:\n        key: Key associated with data.\n        data: Data to put in the store.\n    \"\"\"\n    self.data[key] = data\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.ZeroMQServer.handle_rpc","title":"handle_rpc()","text":"<pre><code>handle_rpc(rpc: RPC) -&gt; RPCResponse\n</code></pre> <p>Process an RPC request.</p> <p>Parameters:</p> <ul> <li> <code>rpc</code>             (<code>RPC</code>)         \u2013          <p>Client RPC to process.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RPCResponse</code>         \u2013          <p>Response containing result or an exception if the operation failed.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def handle_rpc(self, rpc: RPC) -&gt; RPCResponse:\n    \"\"\"Process an RPC request.\n\n    Args:\n        rpc: Client RPC to process.\n\n    Returns:\n        Response containing result or an exception if the operation failed.\n    \"\"\"\n    response: RPCResponse\n    try:\n        if rpc.operation == 'exists':\n            exists = self.exists(rpc.key.obj_id)\n            response = RPCResponse('exists', key=rpc.key, exists=exists)\n        elif rpc.operation == 'evict':\n            self.evict(rpc.key.obj_id)\n            response = RPCResponse('evict', key=rpc.key)\n        elif rpc.operation == 'get':\n            data = self.get(rpc.key.obj_id)\n            response = RPCResponse('get', key=rpc.key, data=data)\n        elif rpc.operation == 'put':\n            assert rpc.data is not None\n            self.put(rpc.key.obj_id, rpc.data)\n            response = RPCResponse('put', key=rpc.key)\n        else:\n            raise AssertionError('Unreachable.')\n    except Exception as e:\n        response = RPCResponse(rpc.operation, key=rpc.key, exception=e)\n    return response\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.run_server","title":"run_server()  <code>async</code>","text":"<pre><code>run_server(\n    address: str, port: int, chunk_length: int | None = None\n) -&gt; None\n</code></pre> <p>Listen and reply to RPCs from clients.</p> Warning <p>This function does not return until SIGINT or SIGTERM is received.</p> <p>Parameters:</p> <ul> <li> <code>address</code>             (<code>str</code>)         \u2013          <p>IP address the server should bind to.</p> </li> <li> <code>port</code>             (<code>int</code>)         \u2013          <p>Port the server should listen on.</p> </li> <li> <code>chunk_length</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Message chunk size in bytes. Defaults to <code>MAX_CHUNK_LENGTH_DEFAULT</code>.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>async def run_server(\n    address: str,\n    port: int,\n    chunk_length: int | None = None,\n) -&gt; None:\n    \"\"\"Listen and reply to RPCs from clients.\n\n    Warning:\n        This function does not return until SIGINT or SIGTERM is received.\n\n    Args:\n        address: IP address the server should bind to.\n        port: Port the server should listen on.\n        chunk_length: Message chunk size in bytes. Defaults to\n            `MAX_CHUNK_LENGTH_DEFAULT`.\n    \"\"\"\n    loop = asyncio.get_running_loop()\n    close_future = loop.create_future()\n\n    loop.add_signal_handler(signal.SIGINT, close_future.set_result, None)\n    loop.add_signal_handler(signal.SIGTERM, close_future.set_result, None)\n\n    server = ZeroMQServer()\n    chunk_length = (\n        MAX_CHUNK_LENGTH_DEFAULT if chunk_length is None else chunk_length\n    )\n\n    context = zmq.asyncio.Context()\n    socket = context.socket(zmq.REP)\n    socket.setsockopt(zmq.RCVTIMEO, 100)\n\n    with socket.bind(f'tcp://{address}:{port}'):\n        while not close_future.done():\n            try:\n                rpc_parts = await socket.recv_multipart()\n            except zmq.error.Again:\n                continue\n\n            rpc_bytes = b''.join(rpc_parts)\n\n            if rpc_bytes == b'ping':\n                await socket.send(b'pong')\n                continue\n\n            rpc: RPC = deserialize(rpc_bytes)\n            response = server.handle_rpc(rpc)\n\n            message = serialize(response)\n            await socket.send_multipart(\n                list(chunk_bytes(message, chunk_length)),\n            )\n\n    loop.remove_signal_handler(signal.SIGINT)\n    loop.remove_signal_handler(signal.SIGTERM)\n\n    socket.close()\n    context.term()\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.start_server","title":"start_server()","text":"<pre><code>start_server(\n    address: str, port: int, chunk_length: int | None = None\n) -&gt; None\n</code></pre> <p>Run a local server.</p> Note <p>This function creates an event loop and executes <code>run_server()</code> within that loop.</p> <p>Parameters:</p> <ul> <li> <code>address</code>             (<code>str</code>)         \u2013          <p>IP address the server should bind to.</p> </li> <li> <code>port</code>             (<code>int</code>)         \u2013          <p>Port the server should listen on.</p> </li> <li> <code>chunk_length</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Message chunk size in bytes. Defaults to <code>MAX_CHUNK_LENGTH_DEFAULT</code>.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def start_server(\n    address: str,\n    port: int,\n    chunk_length: int | None = None,\n) -&gt; None:\n    \"\"\"Run a local server.\n\n    Note:\n        This function creates an event loop and executes\n        [`run_server()`][proxystore_ex.connectors.dim.zmq.run_server] within\n        that loop.\n\n    Args:\n        address: IP address the server should bind to.\n        port: Port the server should listen on.\n        chunk_length: Message chunk size in bytes. Defaults to\n            `MAX_CHUNK_LENGTH_DEFAULT`.\n    \"\"\"\n    asyncio.run(run_server(address, port, chunk_length))\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.spawn_server","title":"spawn_server()","text":"<pre><code>spawn_server(\n    address: str,\n    port: int,\n    *,\n    chunk_length: int | None = None,\n    spawn_timeout: float = 5.0,\n    kill_timeout: float | None = 1.0\n) -&gt; multiprocessing.Process\n</code></pre> <p>Spawn a local server running in a separate process.</p> Note <p>An <code>atexit</code> callback is registered which will terminate the spawned server process when the calling process exits.</p> <p>Parameters:</p> <ul> <li> <code>address</code>             (<code>str</code>)         \u2013          <p>IP address the server should bind to.</p> </li> <li> <code>port</code>             (<code>int</code>)         \u2013          <p>Port the server will listen on.</p> </li> <li> <code>chunk_length</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Message chunk size in bytes. Defaults to <code>MAX_CHUNK_LENGTH_DEFAULT</code>.</p> </li> <li> <code>spawn_timeout</code>             (<code>float</code>, default:                 <code>5.0</code> )         \u2013          <p>Max time in seconds to wait for the server to start.</p> </li> <li> <code>kill_timeout</code>             (<code>float | None</code>, default:                 <code>1.0</code> )         \u2013          <p>Max time in seconds to wait for the server to shutdown on exit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Process</code>         \u2013          <p>The process that the server is running in.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def spawn_server(\n    address: str,\n    port: int,\n    *,\n    chunk_length: int | None = None,\n    spawn_timeout: float = 5.0,\n    kill_timeout: float | None = 1.0,\n) -&gt; multiprocessing.Process:\n    \"\"\"Spawn a local server running in a separate process.\n\n    Note:\n        An `atexit` callback is registered which will terminate the spawned\n        server process when the calling process exits.\n\n    Args:\n        address: IP address the server should bind to.\n        port: Port the server will listen on.\n        chunk_length: Message chunk size in bytes. Defaults to\n            `MAX_CHUNK_LENGTH_DEFAULT`.\n        spawn_timeout: Max time in seconds to wait for the server to start.\n        kill_timeout: Max time in seconds to wait for the server to shutdown\n            on exit.\n\n    Returns:\n        The process that the server is running in.\n    \"\"\"\n    server_process = multiprocessing.Process(\n        target=start_server,\n        args=(address, port, chunk_length),\n    )\n    server_process.start()\n\n    def _kill_on_exit() -&gt; None:  # pragma: no cover\n        server_process.terminate()\n        server_process.join(timeout=kill_timeout)\n        if server_process.is_alive():\n            server_process.kill()\n            server_process.join()\n        logger.debug(\n            'Server terminated on parent process exit '\n            f'(pid={server_process.pid})',\n        )\n\n    atexit.register(_kill_on_exit)\n    logger.debug('Registered server cleanup atexit callback')\n\n    wait_for_server(address, port, timeout=spawn_timeout)\n    logger.debug(\n        f'Server started (host={address}, port={port}, pid={server_process.pid})',\n    )\n\n    return server_process\n</code></pre>"},{"location":"api/connectors/dim/zmq/#proxystore_ex.connectors.dim.zmq.wait_for_server","title":"wait_for_server()","text":"<pre><code>wait_for_server(\n    address: str, port: int, timeout: float = 0.1\n) -&gt; None\n</code></pre> <p>Wait until the server responds.</p> <p>Parameters:</p> <ul> <li> <code>address</code>             (<code>str</code>)         \u2013          <p>Host of the server to ping.</p> </li> <li> <code>port</code>             (<code>int</code>)         \u2013          <p>Port of the server to ping.</p> </li> <li> <code>timeout</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>Max time in seconds to wait for server response.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServerTimeoutError</code>           \u2013          <p>If the server does not respond within the timeout.</p> </li> </ul> Source code in <code>proxystore_ex/connectors/dim/zmq.py</code> <pre><code>def wait_for_server(address: str, port: int, timeout: float = 0.1) -&gt; None:\n    \"\"\"Wait until the server responds.\n\n    Args:\n        address: Host of the server to ping.\n        port: Port of the server to ping.\n        timeout: Max time in seconds to wait for server response.\n\n    Raises:\n        ServerTimeoutError: If the server does not respond within the timeout.\n    \"\"\"\n    start = time.time()\n    context = zmq.Context()\n    socket = context.socket(zmq.REQ)\n    socket.setsockopt(zmq.LINGER, 0)\n    socket.connect(f'tcp://{address}:{port}')\n    socket.send(b'ping')\n\n    poller = zmq.Poller()\n    poller.register(socket, zmq.POLLIN)\n\n    while time.time() - start &lt; timeout:\n        # Poll for 100ms\n        event = poller.poll(100)\n        if len(event) != 0:\n            response = socket.recv()\n            assert response == b'pong'\n            socket.close()\n            return\n\n    socket.close()\n\n    raise ServerTimeoutError(\n        f'Failed to connect to server within timeout ({timeout} seconds).',\n    )\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#getting-started-for-local-development","title":"Getting Started for Local Development","text":"<p>We recommend using Tox to setup the development environment. This will create a new virtual environment with all of the required packages installed and ProxyStore installed in editable mode with the necessary extras options.</p> <pre><code>$ git clone https://github.com/proxystore/extensions\n$ cd extensions\n$ tox --devenv venv -e py310\n$ . venv/bin/activate\n</code></pre> <p>Warning</p> <p>Running Tox in a Conda environment is possible but it may conflict with Tox's ability to find the correct Python versions. E.g., if your Conda environment is Python 3.9, running <code>$ tox -e p38</code> may still use Python 3.9.</p> <p>To install manually: <pre><code>$ git clone https://github.com/proxystore/extensions\n$ cd extensions\n$ python -m venv venv\n$ . venv/bin/activate\n$ pip install -e .[dev,docs]\n</code></pre></p>"},{"location":"contributing/#continuous-integration","title":"Continuous Integration","text":"<p>ProxyStore uses pre-commit and Tox for continuous integration (test, linting, etc.).</p>"},{"location":"contributing/#linting-and-type-checking-pre-commit","title":"Linting and Type Checking (pre-commit)","text":"<p>To use pre-commit, install the hook and then run against files.</p> <pre><code>$ pre-commit install\n$ pre-commit run --all-files\n</code></pre>"},{"location":"contributing/#tests-tox","title":"Tests (tox)","text":"<p>The entire CI workflow can be run with <code>$ tox</code>. This will test against multiple versions of Python and can be slow.</p> <p>Module-level unit-test are located in the <code>tests/</code> directory and its structure is intended to match that of <code>proxystore_extensions/</code>. E.g. the tests for <code>proxystore_extenions/x/y.py</code> are located in <code>tests/x/y_test.py</code>; however, additional test files can be added as needed. Tests should be narrowly focused and target a single aspect of the code's functionality, tests should not test internal implementation details of the code, and tests should not be dependent on the order in which they are run.</p> <p>Code that is useful for building tests but is not a test itself belongs in the <code>testing/</code> directory.</p> <pre><code># Run all tests in tests/\n$ tox -e py39\n# Run a specific test\n$ tox -e py39 -- tests/x/y_test.py::test_z\n</code></pre>"},{"location":"contributing/#tests-docker","title":"Tests (docker)","text":"<p>The test suite mocks certain third-party programs that cannot be installed via pip (e.g., Margo, UCX, Redis). For Margo and UCX, a Docker image is provided at proxystore/images with the software pre-built and Python installed. The tox environments <code>py{version}-dim</code> can be run in the container to validate changes against the un-mocked software.</p> <pre><code>$ docker pull ghcr.io/proxystore/proxystore-dim:nightly\n# Be sure to change the path to your proxystore repo directory\n$ docker run --rm -it --network host -v /path/to/proxystore:/proxystore ghcr.io/proxystore/proxystore-dim:nightly\n# Inside container\n$ tox -e py310-dim\n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<p>If code changes require an update to the documentation (e.g., for function signature changes, new modules, etc.), the documentation can be built using MKDocs.</p> <pre><code># Manually\n$ pip install -e .[docs]\n$ mkdocs build --strict  # Build only to site/index.html\n$ mkdocs serve           # Serve locally\n\n# With tox (will only build, does not serve)\n$ tox -e docs\n</code></pre> <p>Docstrings are automatically generated, but it is recommended to check the generated docstrings to make sure details/links/etc. are correct.</p>"},{"location":"contributing/issues-pull-requests/","title":"Issues and Pull Requests","text":""},{"location":"contributing/issues-pull-requests/#issues","title":"Issues","text":"<p>Issue Tracker</p> <p>We use GitHub issues to report problems, request and track changes, and discuss future ideas. If you open an issue for a specific problem, please follow the template guides.</p>"},{"location":"contributing/issues-pull-requests/#pull-requests","title":"Pull Requests","text":"<p>We use the standard GitHub contribution cycle where all contributions are made via pull requests (including code owners!).</p> <ol> <li>Fork the repository and clone to your local machine.</li> <li>Create local changes.<ul> <li>Changes should conform to the style and testing guidelines, referenced   above.</li> <li>Preferred commit message format (source):<ul> <li>separate subject from body with a blank line,</li> <li>limit subject line to 50 characters,</li> <li>capitalize first word of subject line,</li> <li>do not end the subject line with a period,</li> <li>use the imperative mood for subject lines,</li> <li>include related issue numbers at end of subject line,</li> <li>wrap body at 72 characters, and</li> <li>use the body to explain what/why rather than how.   Example: <code>Fix concurrency bug in Store (#42)</code></li> </ul> </li> </ul> </li> <li>Push commits to your fork.<ul> <li>Please squash commits fixing mistakes to keep the git history clean.   For example, if commit \"b\" follows commit \"a\" and only fixes a small typo   from \"a\", please squash \"a\" and \"b\" into a single, correct commit.   This keeps the commit history readable and easier to search through when   debugging (e.g., git blame/bisect).</li> </ul> </li> <li>Open a pull request in this repository.<ul> <li>The pull request should include a description of the motivation for the   PR and included changes. A PR template is provided to guide this process.</li> </ul> </li> </ol>"},{"location":"contributing/releases/","title":"Releases","text":""},{"location":"contributing/releases/#release-timeline","title":"Release Timeline","text":"<p>Releases are created on an as-needed basis. Milestones are the Issue Tracker are used to track features to be included in upcoming releases.</p>"},{"location":"contributing/releases/#creating-releases","title":"Creating Releases","text":"<ol> <li>Choose the next version number, referred to as <code>{VERSION}</code> for the    rest of the instructions. ProxyStore versioning follows semver    (<code>major.minor.patch</code>) with optional PEP-440    pre-release/post-release/dev-release segments. Major/minor/patch numbers    start at 0 and pre-release/post-release/dev-release segments start at 1.</li> <li>Update the version in <code>pyproject.toml</code> to <code>{VERSION}</code>.</li> <li>Commit and merge the version updates/changelogs into main.</li> <li>Tag the release commit and push (typically this is the commit updating the    version numbers).    <pre><code>$ git tag -s v{VERSION} -m \"ProxyStore Extensions v{VERSION}\"\n$ git push origin v{VERSION}\n</code></pre>    Note the version number is prepended by \"v\" for the tags so we can    distinguish release tags from non-release tags.</li> <li>Create a new release on GitHub using the tag. The title should be    <code>ProxyStore Extensions v{VERSION}</code>.</li> <li>Official release:<ol> <li>Use the \"Generate release notes\" option and set the previous tag as the previous official release tag. E.g., for <code>v0.4.1</code>, the previous release tag should be <code>v0.4.0</code> and NOT <code>v0.4.1a1</code>.</li> <li>Add an \"Upgrade Steps\" section at the top (see previous releases for examples).</li> <li>Review the generated notes and edit as needed. PRs are organized by tag, but some PRs will be missing tags and need to be moved from the \"Other Changes\" section to the correct section.</li> <li>Select \"Set as the latest release.\"</li> </ol> </li> <li>Unofficial release: (alpha/dev builds)<ol> <li>Do NOT generate release notes. The body can be along the lines of \"Development pre-prelease for <code>V{VERSION}</code>.\"</li> <li>Leave the previous tag as \"auto.\"</li> <li>Select \"Set as a pre-release.\"</li> </ol> </li> </ol>"},{"location":"contributing/style-guide/","title":"Style Guide","text":"<p>See the ProxyStore Style Guide.</p>"}]}